#!/bin/bash
# Filename: pi_ap_toggle.sh
# Usage: sudo ./pi_ap_toggle.sh [ap|client] [SSID] [PASSWORD]
# Example:
#   sudo ./pi_ap_toggle.sh ap           --> start AP
#   sudo ./pi_ap_toggle.sh off          --> stop AP
#   sudo ./pi_ap_toggle.sh client MySSID MyPassword  --> connect wlan1 as client

set -euo pipefail  # Exit on error, undefined variables, and pipe failures

# Configuration
AP_INTERFACE="wlan1"
CLIENT_INTERFACE="wlan0"
AP_SSID="PiHotspot"
AP_PASSWORD="raspberry123"
DHCP_RANGE="192.168.50.10,192.168.50.50,255.255.255.0,24h"
AP_IP="192.168.50.1/24"
HOSTAPD_CONF="/etc/hostapd/hostapd.conf"
HOSTAPD_CONF_BACKUP="/etc/hostapd/hostapd.conf.backup"
DNSMASQ_CONF="/etc/dnsmasq.conf"
DNSMASQ_CONF_BACKUP="/etc/dnsmasq.conf.backup"
SYSCTL_CONF="/etc/sysctl.d/99-pi-ap-forward.conf"
STATE_FILE="/var/lib/pi_ap_toggle.state"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

function log_info() {
    echo -e "${GREEN}[*]${NC} $1"
}

function log_warn() {
    echo -e "${YELLOW}[!]${NC} $1"
}

function log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

function check_root() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

function check_interface() {
    local iface="$1"
    if ! ip link show "$iface" &>/dev/null; then
        log_error "Interface $iface does not exist"
        log_info "Available interfaces:"
        ip link show | grep -E '^[0-9]+:' | awk '{print $2}' | tr -d ':'
        exit 1
    fi
}

function validate_password() {
    local pass="$1"
    local len=${#pass}
    if [[ $len -lt 8 || $len -gt 63 ]]; then
        log_error "WPA2 password must be 8-63 characters long"
        exit 1
    fi
}

function check_dependencies() {
    local missing=()
    for cmd in hostapd dnsmasq nmcli iptables ip; do
        if ! command -v "$cmd" &>/dev/null; then
            missing+=("$cmd")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_warn "Missing dependencies: ${missing[*]}"
        return 1
    fi
    return 0
}

function install_deps() {
    log_info "Installing dependencies..."
    
    if ! apt update; then
        log_error "Failed to update package list"
        exit 1
    fi
    
    if ! apt install -y hostapd dnsmasq iw net-tools iproute2 iptables-persistent; then
        log_error "Failed to install dependencies"
        exit 1
    fi
    
    # Stop services initially
    systemctl stop hostapd 2>/dev/null || true
    systemctl stop dnsmasq 2>/dev/null || true
    systemctl disable hostapd 2>/dev/null || true
    systemctl disable dnsmasq 2>/dev/null || true
    
    log_info "Dependencies installed successfully"
}

function backup_config() {
    local config="$1"
    local backup="$2"
    
    if [[ -f "$config" && ! -f "$backup" ]]; then
        cp "$config" "$backup"
        log_info "Backed up $config to $backup"
    fi
}

function restore_config() {
    local config="$1"
    local backup="$2"
    
    if [[ -f "$backup" ]]; then
        mv "$backup" "$config"
        log_info "Restored $config from backup"
    fi
}

function save_state() {
    local mode="$1"
    echo "$mode" > "$STATE_FILE"
    echo "$(date '+%Y-%m-%d %H:%M:%S')" >> "$STATE_FILE"
}

function get_state() {
    if [[ -f "$STATE_FILE" ]]; then
        head -n 1 "$STATE_FILE"
    else
        echo "none"
    fi
}

function start_ap() {
    log_info "Configuring AP on $AP_INTERFACE..."
    
    # Validate password
    validate_password "$AP_PASSWORD"
    
    # Check if already running
    if systemctl is-active --quiet hostapd; then
        log_warn "AP appears to already be running. Stopping first..."
        stop_ap
    fi
    
    # Backup existing configs
    backup_config "$HOSTAPD_CONF" "$HOSTAPD_CONF_BACKUP"
    backup_config "$DNSMASQ_CONF" "$DNSMASQ_CONF_BACKUP"
    
    # Prevent NetworkManager from managing the AP interface
    log_info "Setting $AP_INTERFACE to unmanaged mode..."
    nmcli device set "$AP_INTERFACE" managed no 2>/dev/null || true
    
    # Bring interface down and up to reset it
    ip link set down dev "$AP_INTERFACE" 2>/dev/null || true
    sleep 1
    
    # Configure static IP for AP
    log_info "Configuring IP address $AP_IP on $AP_INTERFACE..."
    ip addr flush dev "$AP_INTERFACE"
    ip addr add "$AP_IP" dev "$AP_INTERFACE"
    ip link set up dev "$AP_INTERFACE"
    
    # Verify interface is up (check for UP flag, not state)
    if ! ip link show "$AP_INTERFACE" | grep -q "UP"; then
        log_error "Failed to bring up $AP_INTERFACE"
        exit 1
    fi
    
    # Configure hostapd
    log_info "Creating hostapd configuration..."
    cat > "$HOSTAPD_CONF" <<EOF
# Generated by pi_ap_toggle.sh on $(date)
interface=$AP_INTERFACE
driver=nl80211
ssid=$AP_SSID
hw_mode=g
channel=7
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0
wpa=2
wpa_passphrase=$AP_PASSWORD
wpa_key_mgmt=WPA-PSK
rsn_pairwise=CCMP
EOF
    
    # Configure dnsmasq
    log_info "Creating dnsmasq configuration..."
    cat > "$DNSMASQ_CONF" <<EOF
# Generated by pi_ap_toggle.sh on $(date)
interface=$AP_INTERFACE
dhcp-range=$DHCP_RANGE
# Don't forward plain names
domain-needed
# Never forward addresses in non-routed address spaces
bogus-priv
# Don't read /etc/resolv.conf or any other file
no-resolv
# Use Google DNS
server=8.8.8.8
server=8.8.4.4
EOF
    
    # Enable IP forwarding persistently
    log_info "Enabling IP forwarding..."
    echo "net.ipv4.ip_forward=1" > "$SYSCTL_CONF"
    sysctl -w net.ipv4.ip_forward=1
    
    # Setup NAT (check if rule already exists)
    log_info "Configuring NAT/iptables..."
    
    # Flush any existing rules for clean slate
    iptables -t nat -D POSTROUTING -o "$CLIENT_INTERFACE" -j MASQUERADE 2>/dev/null || true
    iptables -D FORWARD -i "$AP_INTERFACE" -o "$CLIENT_INTERFACE" -j ACCEPT 2>/dev/null || true
    iptables -D FORWARD -i "$CLIENT_INTERFACE" -o "$AP_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
    
    # Add NAT rules
    iptables -t nat -A POSTROUTING -o "$CLIENT_INTERFACE" -j MASQUERADE
    iptables -A FORWARD -i "$AP_INTERFACE" -o "$CLIENT_INTERFACE" -j ACCEPT
    iptables -A FORWARD -i "$CLIENT_INTERFACE" -o "$AP_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT
    
    # Save iptables rules
    if command -v netfilter-persistent &>/dev/null; then
        netfilter-persistent save
    elif command -v iptables-save &>/dev/null; then
        iptables-save > /etc/iptables/rules.v4 2>/dev/null || true
    fi
    
    # Start services
    log_info "Starting hostapd and dnsmasq services..."
    systemctl unmask hostapd 2>/dev/null || true
    systemctl enable hostapd
    systemctl enable dnsmasq
    
    if ! systemctl restart hostapd; then
        log_error "Failed to start hostapd. Check logs with: journalctl -xeu hostapd"
        log_info "Config file: $HOSTAPD_CONF"
        exit 1
    fi
    
    if ! systemctl restart dnsmasq; then
        log_error "Failed to start dnsmasq. Check logs with: journalctl -xeu dnsmasq"
        exit 1
    fi
    
    # Verify services are running
    sleep 2
    if ! systemctl is-active --quiet hostapd; then
        log_error "hostapd failed to start properly"
        journalctl -xeu hostapd --no-pager -n 20
        exit 1
    fi
    
    if ! systemctl is-active --quiet dnsmasq; then
        log_error "dnsmasq failed to start properly"
        journalctl -xeu dnsmasq --no-pager -n 20
        exit 1
    fi
    
    # Save state
    save_state "ap"
    
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_info "AP started successfully!"
    log_info "SSID: $AP_SSID"
    log_info "Password: $AP_PASSWORD"
    log_info "IP Address: ${AP_IP%/*}"
    log_info "DHCP Range: ${DHCP_RANGE%%,*} - ${DHCP_RANGE#*,}"
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

function stop_ap() {
    log_info "Stopping AP..."
    
    # Stop services
    if systemctl is-active --quiet hostapd; then
        systemctl stop hostapd
        log_info "Stopped hostapd"
    fi
    
    if systemctl is-active --quiet dnsmasq; then
        systemctl stop dnsmasq
        log_info "Stopped dnsmasq"
    fi
    
    systemctl disable hostapd 2>/dev/null || true
    systemctl disable dnsmasq 2>/dev/null || true
    
    # Flush IP from AP interface
    ip addr flush dev "$AP_INTERFACE" 2>/dev/null || true
    ip link set down dev "$AP_INTERFACE" 2>/dev/null || true
    
    # Remove iptables rules
    log_info "Removing iptables rules..."
    iptables -t nat -D POSTROUTING -o "$CLIENT_INTERFACE" -j MASQUERADE 2>/dev/null || true
    iptables -D FORWARD -i "$AP_INTERFACE" -o "$CLIENT_INTERFACE" -j ACCEPT 2>/dev/null || true
    iptables -D FORWARD -i "$CLIENT_INTERFACE" -o "$AP_INTERFACE" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
    
    # Save iptables rules
    if command -v netfilter-persistent &>/dev/null; then
        netfilter-persistent save
    fi
    
    # Disable IP forwarding
    log_info "Disabling IP forwarding..."
    sysctl -w net.ipv4.ip_forward=0
    rm -f "$SYSCTL_CONF"
    
    # Restore NetworkManager management
    log_info "Restoring NetworkManager management of $AP_INTERFACE..."
    nmcli device set "$AP_INTERFACE" managed yes 2>/dev/null || true
    
    # Restore original configs if they exist
    restore_config "$HOSTAPD_CONF" "$HOSTAPD_CONF_BACKUP"
    restore_config "$DNSMASQ_CONF" "$DNSMASQ_CONF_BACKUP"
    
    # Save state
    save_state "off"
    
    log_info "AP stopped successfully"
}

function connect_client() {
    local SSID="$1"
    local PASS="$2"
    
    if [[ -z "$SSID" || -z "$PASS" ]]; then
        log_error "Usage: $0 client SSID PASSWORD"
        exit 1
    fi
    
    # Validate password
    validate_password "$PASS"
    
    log_info "Connecting $CLIENT_INTERFACE to $SSID..."
    
    # Ensure NetworkManager is managing the interface
    nmcli device set "$CLIENT_INTERFACE" managed yes 2>/dev/null || true
    
    # Bring interface up
    ip link set up dev "$CLIENT_INTERFACE" 2>/dev/null || true
    
    # Disconnect any existing connection on this interface
    log_info "Disconnecting any existing connections on $CLIENT_INTERFACE..."
    nmcli device disconnect "$CLIENT_INTERFACE" 2>/dev/null || true
    sleep 2
    
    # Scan for networks
    log_info "Scanning for networks..."
    nmcli device wifi rescan ifname "$CLIENT_INTERFACE" 2>/dev/null || true
    sleep 3
    
    # Check if network is visible
    if nmcli device wifi list ifname "$CLIENT_INTERFACE" | grep -q "$SSID"; then
        log_info "Network '$SSID' found"
    else
        log_warn "Network '$SSID' not found in scan, attempting connection anyway..."
    fi
    
    # Attempt connection
    log_info "Attempting to connect to $SSID..."
    if nmcli device wifi connect "$SSID" password "$PASS" ifname "$CLIENT_INTERFACE"; then
        log_info "Successfully connected to $SSID"
        
        # Wait for connection to stabilize
        sleep 3
        
        # Verify connection
        if nmcli device show "$CLIENT_INTERFACE" | grep -q "connected"; then
            local ip_addr
            ip_addr=$(ip addr show "$CLIENT_INTERFACE" | grep "inet " | awk '{print $2}')
            
            if [[ -n "$ip_addr" ]]; then
                log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                log_info "Connection successful!"
                log_info "Interface: $CLIENT_INTERFACE"
                log_info "SSID: $SSID"
                log_info "IP Address: $ip_addr"
                
                # Show gateway
                local gateway
                gateway=$(ip route | grep "default.*$CLIENT_INTERFACE" | awk '{print $3}')
                if [[ -n "$gateway" ]]; then
                    log_info "Gateway: $gateway"
                fi
                log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
                
                # Test connectivity
                log_info "Testing connectivity..."
                if timeout 5 ping -c 1 -I "$CLIENT_INTERFACE" 8.8.8.8 &>/dev/null; then
                    log_info "Internet connectivity verified"
                else
                    log_warn "Could not verify internet connectivity"
                fi
            else
                log_warn "Connected but no IP address assigned yet"
            fi
        else
            log_error "Connection established but interface shows as disconnected"
            exit 1
        fi
        
        # Save state
        save_state "client"
    else
        log_error "Failed to connect to $SSID"
        log_info "Possible reasons:"
        log_info "  - Incorrect password"
        log_info "  - Network out of range"
        log_info "  - Authentication method not supported"
        log_info "  - Interface busy or in use"
        exit 1
    fi
}

function show_status() {
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    log_info "Pi AP Toggle Status"
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    local state
    state=$(get_state)
    log_info "Current mode: $state"
    
    if [[ -f "$STATE_FILE" ]]; then
        local timestamp
        timestamp=$(tail -n 1 "$STATE_FILE")
        log_info "Last change: $timestamp"
    fi
    
    echo ""
    log_info "Service Status:"
    systemctl is-active --quiet hostapd && log_info "  hostapd: RUNNING" || log_info "  hostapd: stopped"
    systemctl is-active --quiet dnsmasq && log_info "  dnsmasq: RUNNING" || log_info "  dnsmasq: stopped"
    
    echo ""
    log_info "Network Interfaces:"
    if ip link show "$AP_INTERFACE" &>/dev/null; then
        local ap_status
        ap_status=$(ip link show "$AP_INTERFACE" | grep -oP 'state \K\w+')
        local ap_ip
        ap_ip=$(ip addr show "$AP_INTERFACE" | grep "inet " | awk '{print $2}' || echo "none")
        log_info "  $AP_INTERFACE: $ap_status (IP: $ap_ip)"
    else
        log_warn "  $AP_INTERFACE: NOT FOUND"
    fi
    
    if ip link show "$CLIENT_INTERFACE" &>/dev/null; then
        local client_status
        client_status=$(ip link show "$CLIENT_INTERFACE" | grep -oP 'state \K\w+')
        local client_ip
        client_ip=$(ip addr show "$CLIENT_INTERFACE" | grep "inet " | awk '{print $2}' || echo "none")
        log_info "  $CLIENT_INTERFACE: $client_status (IP: $client_ip)"
        
        # Show connected SSID if any
        local connected_ssid
        connected_ssid=$(nmcli -t -f active,ssid dev wifi | grep "^yes" | cut -d: -f2 || echo "")
        if [[ -n "$connected_ssid" ]]; then
            log_info "  Connected to: $connected_ssid"
        fi
    else
        log_warn "  $CLIENT_INTERFACE: NOT FOUND"
    fi
    
    echo ""
    log_info "IP Forwarding: $(cat /proc/sys/net/ipv4/ip_forward | grep -q 1 && echo "ENABLED" || echo "disabled")"
    
    log_info "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Main execution
check_root
check_interface "$AP_INTERFACE"
check_interface "$CLIENT_INTERFACE"

case "${1:-}" in
    ap)
        if ! check_dependencies; then
            install_deps
        fi
        start_ap
        ;;
    off|stop)
        stop_ap
        ;;
    client)
        if [[ -z "${2:-}" || -z "${3:-}" ]]; then
            log_error "Usage: $0 client SSID PASSWORD"
            exit 1
        fi
        connect_client "$2" "$3"
        ;;
    status)
        show_status
        ;;
    *)
        echo "Usage: $0 [ap|off|client SSID PASSWORD|status]"
        echo ""
        echo "Commands:"
        echo "  ap              Start access point on $AP_INTERFACE"
        echo "  off             Stop access point"
        echo "  client SSID PWD Connect $CLIENT_INTERFACE to WiFi network"
        echo "  status          Show current status"
        echo ""
        echo "Examples:"
        echo "  sudo $0 ap"
        echo "  sudo $0 client MyWiFi MyPassword"
        echo "  sudo $0 off"
        echo "  sudo $0 status"
        exit 1
        ;;
esac
